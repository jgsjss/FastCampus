context란?  사전적 의미로 문맥이며 책갈피의 의미. 서블릿 컨텍스트란 서블릿들이 서로간에 어떤 문맥을 이어가는 저장소

스프링이란 자바 기반 애플리케이션 프레임워크이다. 개발을 빠르고 효율적으로 할 수 있도록 애플리케이션의 바탕이 되는 틀과 공통 프로그래밍 모델, 기술 API를 제공해 준다.

API란? 애플리케이션 프로그래밍 인터페이스(Application Programming Interface)이다. API는 당사자들 간 계약을 나타내는 도큐멘테이션을 갖춘 계약으로 비유되기도 한다.
한쪽 당사자가 특정한 방식으로 구성된 원격 요청을 보내면 다른 쪽 당사자의 소프트웨어가 이에 응답하는 방식이기 때문이다.
웹서버와 고객간의 소통방법, 어떻게 해야 서버와 통신을 할 수 있을까 라는 규약

REST API는 6개의 원칙이 있다.
1.Uniform interface - 하나의 자료는 하나의 url로, url 하나를 알면 둘을 알 수 있어야함, 요청과 응답은 정보가 충분히 들어있어야함.
2.Client-server 역할 구분 - 브라우저는 요청만 할 뿐, 서버는 응답만 할 뿐
3.Stateless - 요청 1과 요청 2는 의존성이 없어야함(독립적)
4.Cacheable - 서버에서 보내주는 정보들은 캐싱이 가능해야함, 캐싱을 위한 버전관리도 잘해야함(노드에선 크롬이 알아서 해줌) 
5.Layered System
6.Code on Demand 

4,5,6은 크게 중요하진 않음 

좋은 REST API
이름 짓기 원칙 : - URL을 명사로 작성추천, 하위문서를 나타낼땐 /, 파일확장자 쓰지말기, 띄어쓰기는 대시(-)사용, 자료 하나당 하나의 URL



// 자바스크립트 관련 스터디

텍스트 에디터(VSC)
모든 운영체제는 터미널 애플리케이션을 내장하고 있으며 이는 처음 시작하기에 좋은 방식이다. 

VSC에서 터미널 사용 Terminal -> New Terminal / 현재 프로젝트와 동일한 디렉터리에 표시됨

Node.js는 크롬의 V8 자바스크립트 엔진을 기반으로 하는 자바스크립트 런타임이다. 
실질적으로 이것은 노드 개발자가 브라우저 환경 외부에서 자바스크립트를 작성할 수 있도록 하는 플랫폼을 의미한다.
Node.js는 기본패키지 관리자인 NPM과 함께 제공되며, NPM을 사용하면 프로젝트 내에 수천개의 라이브러리와 자바스크립트 관련 도구를 설치할 수 있다.

-Node.js의 버전관리, 시스템상에서 여러 버전의 Node.js도 관리해야 할 수도 있기에, 이를 위해 권장하는 노드 설치 도구, 노드 버전 매니저(NVM, https://oreil.ly/fzBp0)이다.
윈도우 사용자의 경우 NVM-windows(https://oreil.ly/qJeej) 를 권장한다.

마크다운이란? 프로그래밍 커뮤니티와 iA Writer, Ulysses, Byword 등과 같은 텍스트 애플리케이션에서 많이 쓰이는 인기있는 텍스트 마크업 언어이다.(www.markdownguide.org/ 참조)

REST(Representational State Transfer) API란 대부분의 API가 취하고 있는 형식이다. REST형식의 API는 URL구조와 쿼리 매개변수를 사용하여 서버에 요청한다는 점에서 그래프QL과 다르다.
REST가 대세이기는 하지만, 그래프QL은 제한된 양의 데이터를 전송하는 덕택에 성능 면에서 이점이 크고 단순성과 견고함도 갖추고 있어 여러 플랫폼에서 쓰이고 있다.

git -clone 과정에서 permission denied 에러가 발생할 수 있다. 이 문제를 해결하려면 공식문서를 참고하거나, git permission denied(publickey) 라고 검색해서 한글로 된 가이드를 읽고 해결한다.
(https://lasdri.tistory.com/809)참고

.env 파일이 안보일 때 - 시스템파일로 간주하고 숨김처리됨, 텍스트 편집기에서 디렉토리를 열어서 확인해보거나 터미널에서 ls -a를 입력하여 확인

Error: Cannot find module 'express' 발생시 - $ npm install express 입력 = 해결안됨 // npm install express 를 notedly 디렉토리에서 실행해야함!! api안에서 하면 오류발생!

package.json Scripts - scripts 객체에는 다양한 도우미 명령어가 있다. 이후의 장에서 이러한 명령어를 자세하게 살펴볼 것이다.

node index.js 명령어 대신 nodemon index.js로 실행하면 서버를 재시작 하지 않아도 브라우저에 즉각 변경내용이 적용된다.

GraphQL 이란?
Graph QL(이하 gql)은 Structed Query Language(이하 sql)와 마찬가지로 쿼리 언어입니다. 
하지만 gql과 sql의 언어적 구조 차이는 매우 큽니다. 또한 gql과 sql이 실전에서 쓰이는 방식의 차이도 매우 큽니다. 
gql과 sql의 언어적 구조 차이가 활용 측면에서의 차이를 가져왔습니다. 이 둘은 애초에 탄생 시기도 다르고 배경도 다릅니다. 
sql은 데이터베이스 시스템에 저장된 데이터를 효율적으로 가져오는 것이 목적이고, gql은 웹 클라이언트가 데이터를 서버로 부터 효율적으로 가져오는 것이 목적입니다. 
sql의 문장(statement)은 주로 백앤드 시스템에서 작성하고 호출 하는 반면, gql의 문장은 주로 클라이언트 시스템에서 작성하고 호출 합니다.

(https://tech.kakao.com/2019/08/01/graphql-basic/ 참조)

apollo-server-express 또한 프로젝트 디렉토리에서 npm install apollo-server-express 명령어 실행으로 설치해야 한다.

' 와 ` 차이 잘 보기....진땀흘림;
간단하게 자바스크립트에서 함수는
1. 변수나 데이터안에 담길 수 있고

2. 매개변수로 전달 할 수 있고

3. 반환 값으로 사용할 수 있고

4. 실행도중에 생성될 수 있다

콜백함수는 이 중에서 두번째 특징을 활용한 내용이다. 콜백함수는 간단하게 다른 함수에 매개변수로 넘겨준 함수를 말한다.

매개변수로 넘겨받은 함수는 일단 넘겨받고, 때가 되면 나중에 호출(called back)한다는 것이 콜백함수의 개념이다.

노드의 단점은 저수준처리를 빠르게 하기 어렵기에, c와 WebAssembly를 통해서 해결한다

노드에서 메일발송 프로그래밍 할때 가장 많이 쓰이는 NODEMAILER

EJS는 HTML 파일 안에서 node.js를 사용할 수 있게 해주는 템플릿 엔진 이다.

웹상에서 노드 코딩 시험해볼 수 있는 사이트 glitch 검색

노드js 관리 프로그램 tj/n 설치를 하려했으나 에러발생/ 운영체제 win32는 지원 안됨

package.json 파일은 패키지에 메타데이터를 포함한 파일이다. 그리고 중요한 역할 중 하나는 프로젝트에서 사용하는 의존성들을 나열하는 것에도 있다.

-메타데이터란? 속성정보라고도 불리며대량으로 존재하고 있는 정보들 사이에서 찾고자 하는 정보를 효율적으로찾아내기 위해서 일정한 규칙에 의거하여 컨텐츠에 부여해주는 데이터 이다
(https://blog.naver.com/ithopenanum/221307206526 참조)

루니버스란? 블록체인 플랫폼이다. 루니버스의 역할은 크게 4가지로 정리할 수 있겠다.

1. 블록체인 기술 대중화

2. 차세대 블록체인 플랫폼 구축

3. 블록체인 기술 업체 발굴과 육성

4. 토큰이코노미 모델 지원 및 신규 모델 개발

타입스크립트는 언어를 지칭하기도 하지만 자바스크립트에 타입정의만 얹어놓은 것으로 봐도 무방하다.
그래서 일반 자바스크립트 프로젝트에서도 사용 가능하다.

jsconfig.json 은 프로젝트의 @ts-check 의 엄격함 정도를 조절 할 수 있다.(compilerOption 에서 strict = false, true 등으로)

자바스크립트의 실행 모델은 event loop, call stack, callback queue 개념으로 이루어진다.

1.이벤트 루프 모델은 여러 스레드를 사용하며, 그중 우리가 작성한 자바스크립트 코드가 실행되는 스레드르르 메인스레드라 부른다.
한 node.js 프로세스에서 메인 스레드는 하나이며, 한순간에 한 줄씩만 실행된다. 
그러나 그외의 일(file I/O, network...)을 하는 워커 스레드는 여러개가 있을 수 있다.
2. 콜스택은 지금 시점까지 풀린 함수들의 스택이다. 스택은 선입후출의 자료 구조.먼저들어온게 아래에 쌓이고, 나중에 들어온게 먼저 나간다.
함수가 호출될 때 쌓이고, 리턴할 때 빠진다.
이벤트루프가 다음 콜백을 처리하려면 지금 처리하고있는 콜백의 실행이 완전히 끝나야 한다.
콜 스택이 완전히 빌 때까지 처리한다는 것과 동일한 말이다.
3. 콜백큐는 콜백들이 쌓이는 큐다. 큐라는 것은 선입선출의 자료구조이다. 먼저 들어온게 먼저 나가는 구조이다.
콜백은 브라우저나 node가 어떤 일이 발생하면(event) 메인 스레드에 이를 알려주기 위해(callback) 사용된다
이벤트는 파일 처리의 완료, 네트워크 작업의 완료, 타이머 호출 등이 있다.

브라우저나 node.js에서나, Web API 혹은 Node API의 동작이 끝나면 callback queue에 등록한다
브라우저나 Node가 요청받은 일을 하고 있는 동안 메인 스레드와 이벤트 루프는 영향을 받지 않고 계속 실행된다
이를 offloading이라고 하며, Node 서버의 메인 스레드가 하나임에도 불구하고 빠르게 동작하는 이유다.
메인 스레드가 오래 걸리는 일을 기다리지 않기 때문이다.

1.콜백큐에서 콜백을 꺼내고(없다면 생길 떄까지 기다리고)
2.그 콜백의 처리가 끝날때까지 실행하고
3.이를 반복한다.

Hoisting - var
var x = 1
console.log(x)
결과 1

console.log(x)
var x = 1
결과 undefined

Hoisting 이란 변수의 선언(만)을 해당 스코프의 맨 위로 끌어올리는 것을 뜻한다.
var 뿐만 아니라 function 또한 동일하게 Hoisting 대상이다.
함수의 선언과 값의 초기화는 서로 다르다.

Function, lexical scope
코드의 어떤 식별자가 실제로 어떤 값이 가르키는지를 결정하는것을 binding 이라 한다.
자바스크립트에서 binding은 lexical scope를 통해 이루어진다
lexical scope란 간단히 말하자면 안쪽에서 바깥쪽 변수에 접근할 수 있단 말이다. 바깥에서 안쪽은 참조할 수 없다.

var, block scoping
var는 block scoping의 대상이 아니다. 
var x = 1
if(true){
    var x =2
}
console.log(x)   
결과는 2가 된다. block scoping이 되었다면 로그는 1이 찍히지만, var는 대상이 아니어서 var x는 2로 초기화된다.
let과 const는 block scoping 대상이다. 
var 변수의 특징, 재선언 가능, 재할당 가능, 생존범위는 블록 안이다.

closure = function + environment 이다
closure는 function이 하나 생길때마다 하나씩 생깁니다.

function and(x){
  return function print(y){
    return x + 'and' + y
  }
}

const saltAnd = and('salt')
console.log(saltAnd('pepper')) //salt and pepper
console.log(saltAnd('sugar'))  //salt and sugar

const waterAnd = and('water')
console.log(waterAnd('juice')) // water and juice
and 함수로 만들어진 saltAnd의 closure는 : 
함수: print
ghksrud: x ->"salt"
이다.

closure는 higher-order function 을 만드는데 유용하다.

saltAnd와 waterAnd 둘다 함수는 같은 print이지만, 각각 주어진 변수가 다릅니다.

saltAnd는 x가 "salt", waterAndsms x가 "water"로 바인딩 되어 있습니다.
즉, 둘은 서로 다른 closure를 형성하고 있습니다.

function foo(){
  function bar(){
  }
  function baz(){
  }
}
foo()

이코드의 실행과정에서 closure는 총 3개가 생성됩니다.
foo1개 bar1개 baz1개



node.js 서버 기본세팅

// @ts-check
// Formatting, Listening
// Formating: Prettier
// Linting: ESLint
// Type checking: TypeScript

const http = require('http')
const server = http.createServer((req, res) => {
  res.statusCode = 200
  res.end('Hello!')
})

const PORT = 4000
server.listen(PORT, () => {
  console.log(`The server is listening at port: ${PORT}`)
})

혹은

// @ts-check
// Formatting, Listening
// Formating: Prettier
// Linting: ESLint
// Type checking: TypeScript

// 설치한 라이브러리를 참고해주세요'express'
const express = require('express')
// 참고한 라이브러리로 객체를 만들어주세요.
const app = express()

app.listen(8080, function () {
  console.log('Listening on 8080')
})

app.get('/', function (req, res) {
  res.statusCode = 200
  res.end('Welcome to My Page')
})

Formating : Prettier  설치/ 익스텐션에서 검색 후 플러그인으로 설치
터미널에서 설치, npm install --save-dev Prettier
그리고 프로젝트 경로에 .prettierrc 파일 생성후 설정
ex){
    "semi":false,    세미콜론 사용x
    "singleQuote": true   싱글쿼트만 사용
}
Linting: ESLint 설치/ 마찬가지로 플러그인 설치 후
터미널에서 설치, npm install --save-dev ESLint
그리고 프로젝트 경로에 .eslintrc.js파일 생성 후 설정
ex) module.exports = {} 이 기본설정
Type checking: TypeScript 설치
npm install --save-dev TypeScript
설치후 서버파일 상단에 // @ts-check
그리고 노드환경에서도 적용시키기 위해 npm install --save-dev @types/node 라이브러리 설치
이제 타입스크립트가 바이너리파일을 이용하여 코드에서 타입체크를 해준다.



npm install body-parser  : 요청데이터(body) 해석을 쉽게 도와주는 라이브러리 설치
DELETE 요청하는법
1. 라이브러리를 설치한다
2. AJAX를 요청한다.

AJAX란? 서버랑 통신할 수 있게 도와주는 , 요청하는걸 도와주는 자바스크립트 문법
-장점. 새로고침없이 서버와 통신한다.

쿠키(cookie)란 브라우저에 저장할 수 있는 긴 문자열이다.

회원 인증 방법
1번째.session-based
사용자의 세션정보를 저장해서 로그인 기능을 구현하는 방법입니다. 

그냥 쉽게말하면

- 이 사람이 로그인 했었다는 정보를 서버의 메모리에다가 기록해놓습니다. (세션을 저장합니다.)

- 그리고 고객이 로그인이 필요한 페이지(Mypage 등)를 요청을 하면 

- 세션을 들춰봐서 이 사람이 로그인했다는 정보가 나오면 통과시켜줌~!

이런 방식입니다. 
좀더 자세히 보자면
1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 

서버는 옳다구나 하고 세션스토어에 세션 하나를 만들어서 저장합니다. 

세션은 용어가 어려워서 그렇지 그냥 이 사람이 언제 어디서 로그인 했는지 이런 정보를 담은 자료라고 보시면 됩니다.

"Kim 이라는 사람이 7시에 로그인했습니다."

뭐 이런 정보를 서버 메모리에 저장해둡니다. 

 

2. 그리고 로그인한 유저마다 각각 유니크한 세션아이디라는걸 발급합니다. 

당연히 로그인한 사람이 여러명일 수 있으니 유니크한 세션아이디를 발급해서 구분지어주는게 좋겠죠.

그래서 abc123 이라고 세션아이디를 하나 예쁘게 발급해줬습니다. 

 

3. 발급한 세션아이디는 쿠키에 담아서 고객 브라우저에 전송해줍니다. 

세션아이디는 고객과 서버 둘다 보관합니다. 그래서 쿠키에 담아서 고객에게 보내줍니다.

* 쿠키란 브라우저에 마련되어있는 쪼그만한 문자데이터 저장공간입니다. 여기에 세션아이디가 abc123 이렇게 기록됩니다. 

- 여기까지가 로그인 기능 구현 끝입니다. 

 

그럼 이제 고객에 로그인이 필요한 페이지를 요청한 경우,

이 사람이 적법하게 로그인 했던 사람인지 검사해보도록 합시다. 

 

1. 고객이 로그인합니다. 

아이디 / 비번을 서버로 전송하면 

서버는 기존에 있던 DB에 아이디/비번 세트가 존재하면 옳다구나 하고 세션아이디를 만들어줍니다. 

그리고 세션아이디들을 담을 변수나 뭐 DB 공간을 마련해서 거기 저장해둡니다. 그걸 세션데이터라고 부릅시다. 

(저장은 DB에 할 수도 있고 서버 메모리(그냥 변수)에 저장할 수 있습니다. )

그리고 세션 아이디를 쿠키라는 것에 이쁘게 포장해서 고객의 브라우저에 쿠키를 강제로 저장시킵니다. 

 

2. 고객이 마이페이지를 요청합니다. 

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 심플합니다. 

 

3. 쿠키에 세션아이디가 포함되어있는지 검사합니다. 

원래 고객이 페이지를 요청할 때 마다 자동으로 쿠키가 서버로 전송됩니다.

그럼 서버는 쿠키에 기록된 세션아이디를 서버메모리 or DB에 저장되어있던 세션아이디와 비교해서

있으면 통과시켜줍니다. 

 

4. 서버는 마이페이지를 보내줍니다. 

그 전에 이 회원의 이름, 나이, 성별 등의 DB 정보가 필요하다면

세션데이터를 참고해서 이 사람의 이름, 나이 등의 정보를 DB에서 꺼내옵니다. 

끝입니다. 



실은 로그인기능 구현 그거 별거 아닙니다. 

아이디/비번을 DB에 기록할 수 있는 회원가입 폼 알아서 만들어두시고 (진심 별거아님)

어떤 사람이 로그인하면 세션아이디를 하나 발급해서 서버와 고객이 나눠가집니다. 

그리고 고객이 마이페이지같은거 요청할 때마다 "니 세션아이디 뭔데" 라고 물어보면 됩니다. 

 

세션은 매우 전통적이고 범용적으로 사용되는 인증방식입니다. 

그러므로 여러분이 개발 중 위기에 처했을 때 참고할 구글 검색결과가 풍부합니다. 


회원 인증 방법
2번째. JSON Web Token (JWT)

토큰 방식은 세션데이터를 서버에 저장하지 않고

마이페이지를 열람할 수 있는 열쇠(토큰)를 사용자에게 쥐어주는 것입니다. 

그래서 그 열쇠에는 session방식보다 약간 더 많은 정보들이 들어갑니다. 

요즘 토큰토큰 거리면 JSON Web Token을 말하는 것인데, 아무튼 어떤 방식인지 자세히 알아보도록 합시다. 

 

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 

서버는 옳다구나 하고 Token 하나를 만들어서 고객 브라우저로 보내줍니다. 

Token은 그냥 긴 암호화된 문자열일 뿐이고, 사용자가 로그인 했었는지, 아이디는 무엇인지 이런 정보들을 넣을 수 있습니다. 

물론 위조가 불가능하도록 특별한 서명이 추가됩니다. 

토큰은 쿠키나 로컬스토리지라는 곳에 저장됩니다. 

(+ 코드를 잘 짜서 고객이 페이지 방문시마다 Token이 서버로 보내지도록 미리 장치를 추가합니다. )

 

2. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 그냥 토큰 검사입니다. 

 

3. 서버는 토큰을 검사합니다

고객이 마이페이지 요청시 함께 보낸 Token이 적법한지 검사합니다. 

유통기한이 지나지 않았는지, 서명이 잘 되어있는지, 블랙리스트에 등록된 토큰인지 이런 검사를 거친 후

이상이 없으면 마이페이지로 통과시켜줍니다. 

 

 

끝입니다. 

기본적인 토큰 구현은 매우 간단합니다.

그리고 서버는 세션데이터 등을 메모리/DB에 저장해둘 필요가 없으니 나중에 서버 스케일링시 큰 문제가 없다는 장점도 있습니다. 

 

하지만 단점이나 보안상 취약점이 존재할 수 있습니다.

이 사람이 로그인 했는지에 대한 정보 전체를 서버는 가지고 있지 않고 사용자가 가지고 있게 하는 것 자체가 보안상 좋은 방법은 아닙니다.

JWT 정보를 다른 사람이 훔치면 어쩔 것임? 이제 훔친 사람은 자유롭게 로그인이 가능하겠는데요? 

그래서 stateful JWT 라고 부르는 '어떤 사람이 언제 로그인했는지'를 서버에 저장해두는 방식이 좋은 관습이긴 한데

그 중 하나가 refresh token 이런 방식입니다.  

그러면 위에서 말했던 세션 방식이랑 기능 상 다를바가 없습니다. 



회원인증방법
3번쨰. 3. Open Autentication

 

이 방법은 쉽게말하면 페이스북, 구글 로그인입니다.

고객의 페이스북, 구글 계정정보를 불러와서 그걸 가지고 가입을 승인시켜주는 방법입니다. 

1. 어떤 사람이 '페이스북으로 로그인' 버튼을 눌렀다고 칩시다. 

그럼 페이스북 팝업이 뜹니다. 

"코딩애플 앱에 본인의 페이스북 이름, 아이디 제공을 승인하시겠습니까?"

승인을 눌러봅니다. 

 

2. 그럼 페이스북은 우리 server.js에게 이 유저의 이름, 아이디 정보를 보내줍니다. 

그럼 뭘 해야할까요. 여러분이 하고싶은거 하시면 됩니다.

 

3. 이 사람 페이스북 정보를 바탕으로 세션이나 토큰을 만들어줍니다. 

DB에 이름, 아이디를 저장해서 회원 목록을 하나 만들어주든가,

그와 동시에 세션 데이터를 만들어주든가 하시면 됩니다. 

server.js에 코드를 잘 짜서 하면 되겠죠.

 

4. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

 

5. 서버는 토큰이나 세션을 검사합니다

위에서 세션을 만들어 줬다면 세션이 있는지 검사하면 되고,

위에서 토큰을 만들어 줬다면 토큰이 적법한지 검사하면 되겠죠?

통과되면 마이페이지를 응답.render() 해줍니다.



비밀번호를 취급안해도 된다는 장점 때문에 관리도 편리하고 유저도 편리함을 느낍니다. 

페이스북 등에서 제공하는 공식 개발문서가 많기 때문에 따라하기만 하면 일사천리로 개발이 가능합니다. 

하지만 단점은 구글이나 페이스북이 1. OAuth를 중단하거나 2. 방법을 수정하거나 3. 페이스북 API 서버 다운으로 접속이 불가능하다면

우리 사이트 로그인도 불가능합니다. 

페이스북은 맨날 OAuth 방법이나 정책 이런걸 변경했다고 메일자주보내는데 그래서 약간 관리하기 귀찮은 면도 있습니다. 


라우팅(영어: routing)은 어떤 네트워크 안에서 통신 데이터를 보낼 때 최적의 경로를 선택하는 과정이다.


.env파일에 대하여

-여태까지 작성한 server 코드를 잘 보시면 이런 코드가 존재합니다. 
var db;
MongoClient.connect('mongodb+srv://codingapple1:어쩌구@저쩌구', function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(8080, function() {
    console.log('listening on 8080')
  })
}) 

서버 띄울 때 맨 처음 작성했던 코드인데

여기에 잘 보시면 8080이라는 포트번호, mongodb+srv라고 시작하는 이상한 DB접속 문자열이 존재합니다. 

이런 값들은 다른 개발환경이나 다른 컴퓨터로 코드를 옮긴다면 수정이 필요할 수 있습니다.

 

-다른 컴퓨터에선 8070 포트를 연다든지,

- 나중에 DB 이사를 가서 DB접속 문자열이 바뀐다든지

- 아니면 내가 만든 코드를 팀원과 share 해야하는데 내 아이디 비번이 적혀있으면 좀 그렇잖습니까 

이런 환경에 따라 가변적인 변수 데이터들을 보통 환경변수라고 부르는데 

(멋있는 영어로 environment variable 이라고 합니다.)

그래서 개발자들은 미래를 생각하는 코딩을 하기 위해 환경변수를 한곳에 모아서 관리합니다. 

.env파일이라는 곳입니다. 

.env파일에 모든 중요 환경변수들을 다 쑤셔박아넣은 뒤에,

server.js에 가서 ".env파일에 있는 포트숫자를 여기에 넣어주세요~" 이런 식으로 코딩합니다.

이 경우 server.js 파일이 털릴 경우에도 중요한 정보들은 env 파일에 있기 때문에 조그만한 보안상 이점도 있긴 있습니다. 

구체적으로 어떻게 사용하는지 튜토리얼 들어갑니다.

1. 환경변수 사용을 위한 라이브러리를 설치합니다.

오늘도 어김없이 라이브러리 설치입니다. 

터미널을 켜시고 npm install dotenv 라고 입력하셔서 설치하시면 됩니다. 

2. 환경변수가 있는 server.js에 방금 설치한 라이브러리를 등록합니다.

require('dotenv').config()

3. server.js와 같은 경로에 .env 파일을 하나 만들어줍니다.

그리고 내부에 여러분이 나중에 변경이 될 것 같은 환경변수들을 전부 다 적고 저장해주시면 됩니다.

4. 그럼 환경변수들을 server.js에다가 불러오도록 합시다.

server.js에서 env파일의 변수들을 불러오실 때는 process.env.변수이름 이렇게 불러올 수 있습니다.

(기존 server.js 코드)

var db;
MongoClient.connect('mongodb+srv://codingapple1:어쩌구@저쩌구', function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(8080, function() {
    console.log('listening on 8080')
  })
}) 


(env 파일을 적용하는 server.js 코드)

var db;
  MongoClient.connect(process.env.DB_URL, function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(process.env.PORT, function() {
    console.log('listening on 8080')
  })
}) 

위는 기존 코드, 밑은 env파일 내의 환경변수를 적용한 코드입니다.

밑에 처럼 코드를 짜시면 이제 나중에 환경변수 변경이 필요할 때

직접 server.js 코드를 뒤져서 바꾸는게 아니라 .env 파일만 손보면 되니 약간 더 편리하겠죠?

여러분이 나중에 AWS, Google, Naver 클라우드 등을 이용해서 서버를 발행할 때

env파일을 똑같이 이용할 수 있습니다. 

구글 클라우드 서비스에 올릴 경우 env 파일을 따로 만드는게 아니라 app.yaml 파일 내에 환경변수들을 포함해야하는데

https://cloud.google.com/appengine/docs/standard/nodejs/config/appref#environment_variables

이런 곳을 참고해서 똑같이 환경변수를 제작하면 되겠습니다. 

다만 변수만드는 문법에 등호 대신 콜론 (:)을 씁니다.


정규표현식-정규식은 문자를 검사하는 식입니다. // 안에다가 문자를 담으면 검사해줍니다. 

/abc/ 이렇게 적으면 문자에 abc라는게 들어있냐~ 라고 검사해줄 수 있으니 이거 쓰면 해결입니다.
그러나 위의 것은 임시방편이고, 문제가 생길 수 있습니다.



Database가 게시물을 찾는 방법 

원래 게시물을 그냥 찾으면 매우 느립니다.

원하는걸 찾으려면 게시물 100만개를 전부 탐색해야하니까요.

그래서 데이터베이스는 보통 Binary Search라는걸 사용할 수 있습니다. 

 

이게 뭐냐면 제가 1부터 100까지 숫자를 하나 생각해볼테니 여러분이 한번 찾아보시길 바랍니다.

빠르게 찾고싶으면 저에게 어떻게 질문을 던져야할까요.


1입니까 2입니까~~ 이렇게 하나하나 물어보면 평생걸리겠죠?

그래서 똑똑한 사람들은 "50 이상입니까?" 라고 물어봅니다.

예라고 답하면 그 다음은 "75 이상입니까?" 라고 물어봅니다.

이렇게 반을 잘라가면서 물어보면 매우 빠르게 최소한의 질문으로 찾아낼 수 있습니다. 

5~6번만 질문 던지면 100개 중에 내가 원하는 항목을 빠르게 찾을 수 있게 됩니다.

게시물이 100만개라도 20번만 물어보면 될걸요? 

이게 Binary Search라는 알고리즘입니다.


거의 모든 Database들은 기본적으로 이걸로 게시물을 찾아주는데

근데 이걸 쓰려면 조건이 있습니다. 숫자가 1부터 100까지 미리 정렬이 되어있어야합니다.

그래야 "50 이상입니까~" 라고 물어보죠.


그럼 글제목도 빠르게 찾으려면

 

미리 정렬해두면 되지 않을까요? (글자도 정렬이 가능합니다)

맞습니다 이걸 멋진 용어로 indexing이라고 합니다. 

indexing을 해두면 이제 글자로 뭔가 검색할 때 매우 빠르게 찾을 수 있습니다.

indexing 하려면 MongoDB Atlas 들어가셔서

원하는 Collection 안에서 Index 만들기 누르시면 됩니다.



Google Cloud로 5분만에 내 사이트 배포하자 ($300 무료 크레딧!)
 

(변동사항이 많아서 글로 진행합니다)

 

이제 부끄럽게도 여러분이 만든 서버를 웹에 공개할 시간입니다.

 

 

 

 

배포 전 여러분 프로젝트 확인사항 :

 

1. 여러분 프로젝트 폴더에 app.yaml파일을 하나 만들어줍니다. 

app.yaml 파일은 구글 클라우드 배포시 프로젝트 설정 등을 내포한 파일입니다. 

에디터를 이용해 server.js랑 동일한 위치에 app.yaml 파일을 하나 만드시면 되겠습니다. 

그리고 다음 코드를 복붙합니다. 

 

runtime: nodejs
env: flex

manual_scaling:
  instances: 1
resources:
  cpu: 1
  memory_gb: 0.5
  disk_size_gb: 10
위 코드는 구글에서 샘플로 보여주는 app.yaml 파일 예시입니다.

그대로 따라 적으면 되겠습니다. 서버의 CPU, 메모리 용량도 셋팅 가능합니다.

위 예시는 돈많이 안쓰려고 극 저용량으로 셋팅한 예시입니다.

(CPU두개에 메모리 4GB는 되어야 보통 사이트를 운영할 만 합니다.)

 

실제 사이트 운영하시려면 맨 위 두줄만 적어보셔도 됩니다.  

구글이 알아서 트래픽에 따라 서버 크기와 사양을 늘려줍니다.

 

 

 

 

 

2. server.js에 서버를 띄울 때 포트가 8080인지 확인합니다.

 

app.listen 이 부분이 8080인지 확인합시다. 

app.listen(8080, function() {
    console.log('listening on 8080')
  }) 
아니라면 8080으로 변경해줍시다.

왜냐면 구글클라우드에서 기본적으로 이용하는 포트가 8080입니다. 

8080쓰기 싫으시면 따로 설정해주시면 되는데 귀찮으니 8080으로 맞춥니다. 

 

 

 

 

3. MongoDB Atlas의 Network Access 메뉴에서 Whitelist IP를 모든 아이피에서 허용으로 변경합니다.

MongoDB Atlas 오랜만에 들어가신 후 

▼ 왼쪽에서 Network Access 메뉴에서 아이피 등록하는 부분 있죠?

 



 

여기서 모든 아이피 (0.0.0.0)에서 DB 접속을 허용하도록 변경해줍니다. 

(혹은 Allow Access from Anywhere 버튼 클릭)

구글 클라우드에 배포한 여러분의 서버에서도 접속을 해야하니 그렇습니다.

구글 클라우드 안에서 모든걸 해결하고 싶다면 구글이 제공하는 Firestore 라는 NoSQL DB도 이용가능합니다.

지금까지 썼던 MongoDB Atlas 이것도 구글 클라우드 파트너어쩌구던데 아무튼 찾아보십시오. 

 

 

 

 

 

1. Google cloud platform 가입 

 



cloud.google.com 혹은

구글에 구글클라우드라고 검색하신 후 들어가서 로그인까지 합시다. 

그리고 시작하기 버튼을 눌러보도록 합시다. 

 

 

 

2. 가입창 버그 해결하기

 



 

시작하기 버튼을 누른 후 정보등록까지 진행하시면 끝입니다. 

 

간혹 '계속' 버튼을 눌러도 다음으로 안넘어가는 버그가 있을 수 있습니다 

https://cloud.google.com/gcp/getting-started/?hl=ko

버그가 있을 땐 여기서 가입 진행해주시면 됩니다. 

 

 

 

 

▼ 그리고 여기서 무료로 사용 or 활성화 버튼을 눌러서 카드 등록까지 마치십시오. 

 



 

 

필히 카드를 하나 등록하셔야 서비스 이용이 가능하며 등록하면 무료 크레딧 $300을 줍니다. (사용기간 3개월)

- 아마존처럼 자동으로 과금되진 않습니다. 여러분 승인이 있어야 자동과금됩니다. 

 

 

 

 

3. 새로운 프로젝트를 만들거나 기존 프로젝트를 선택합니다.

 



 

상단에 프로젝트 선택하는 드롭다운 메뉴가 있는데 여기서 프로젝트를 하나 고르시거나 만드시면 됩니다.

하나 새로 만드시면 프로젝트 이름이랑 ID를 예쁘게 맘대로 설정가능합니다. 

(기본적으로 My First Project가 하나 만들어져있는데 그거 쓰셔도 됩니다)

 

 

 

 

 

4. 왼쪽 메뉴에서 App Engine을 선택한 후 애플리케이션 만들기를 진행합시다. 

 



 

App Engine 이라는게 여러분이 만든 웹서버 배포할 수 있는 상품이라고 보시면 됩니다.

아무튼 application 만들기 쭉 따라하시면 됩니다. 

 

Region 선택시 서울로 위치를 설정합시다. (asia-northeast3) 서울 없으면 일본 이런거 하셈 

여러분이 사용할 서버용 컴퓨터를 한대 구매하는거라고 보시면 되는데

그 컴퓨터가 물리적으로 가까워야 응답시간이 줄어듭니다.

 

서버에 있는 HTML 파일이 무슨 위성 전파를 타고 오는게 아니라 광케이블을 타고 빛의 속도로 이동하는데

빛의 속도로 미국에서 한국까지 이동해도 최소 150ms 정도 소요됩니다. 

그래서 미국에 있는 HTML 파일을 가져올 땐 요청 & 응답이 이루어져야하니 최소 300ms 는 지연되고 시작하는 겁니다. 

그래서 여러분이 보는 미국 야동사이트들이 느린것이고

미국인들과 실시간 FPS게임을 즐길 수 없는 이유입니다.

 

 

그래서 국내 서비스를 할거라면 네이버 클라우드, cafe24 등을 이용하는 것도 좋은 옵션인데

이제 구글이나 아마존도 서울서버 제공하니까 뭐 암튼 그렇습니다. 

근데 서울같은 변두리 지역은 요금이 미국 이런 곳보다 약간 비쌉니다. 

 

 

 

 

 

 



 

- 환경은 당연히 Node.js, 표준으로 설정하시면 됩니다.

그럼 끝입니다. SDK 어쩌구 뭘 다운받으라고 하네요. 다운받읍시다. 

 

 

 

 

 

 

5. 배포를 위해 Cloud SDK라는 프로그램을 다운로드하고 설치까지 합니다. 

 

Cloud SDK 설치파일을 다운받습니다. 

 



 



 

이런게 안뜬다면 구글에 google cloud SDK 검색해서 설치하셔도 됩니다. https://cloud.google.com/sdk?hl=ko

설치과정에서의 어려움은 없을테니 뭐 건드리지말고 그냥 쭉 넘어갑시다.

맥북을 쓰신다면 설치 방법이 약간 복잡할 수 있으니 위 링크의 튜토리얼 잘 따라하시길 바랍니다.  

맥 설치시 python2.7이 없다고 나오면 구글에 검색하여 설치하시면 됩니다. 

 

 

 

 

 

 

6. 여러분 여태까지 만든 프로젝트 폴더를 VScode 에디터로 오픈한 뒤 터미널을 엽니다. 

 

빨리 오픈하십시오.

 

6-1. 그 다음에 터미널에 gcloud init 이라고 입력합니다. 

gcloud init
gcloud 명령어를 찾을 수 없습니다 그렇게 나오면 설치가 제대로 되지 않은 것입니다. 

(혹은 윈도우라면 시작 - 검색 - cmd 에서 실행해보시길 바랍니다)

 

 

6-2. 구글 계정으로 로그인합니다. 

To continue, you must log in. Would you like to log in (Y/n)? Y 
Y를 입력하면 됩니다.

당연히 구글 클라우드 플랫폼 개설한 구글아이디로 로그인하십시오. 

 

 

6-3. 원하는 프로젝트를 선택합니다. (프로젝트가 하나면 안나옴)

Pick cloud project to use: 
[1] [my-project-1] 
[2] [my-project-2] ... 
Please enter your numeric choice: 
여러분이 클라우드 플랫폼에서 만든 프로젝트 중 하나를 택하라고 합니다.

숫자를 입력해서 택하시면 됩니다. 

끝입니다. 뭔가 해커가 된 느낌입니다. 

 

 

 

 

7. 터미널에 다시 gcloud app deploy라고 입력합니다. 

 

gcloud app deploy
(여러분 작업폴더에서 터미널을 여신후 이 명령어를 입력하십시오 제발!)

 



 

그럼 이상한 안내문이 뜨는데 여러분이 배포할 소스파일, 이름, url 등을 알려줍니다.

(target url이 여러분 사이트 주소입니다)

source : 어쩌구 부분이 여러분 작업폴더가 맞으면 y를 입력합니다. 

이제 구글 AI가 우리 프로젝트 뭔지 분석하고 npm install도 해주고 알아서 다 해줍니다.

AWS였다면 인스턴스 생성부터 시작해서 어려운거 하라그러고 개발이 처음이라면 불편한 점이 많았을 텐데 

구글 클라우드 서비스는 알아서 다 해줍니다. 5~10분 기다리는 것 밖에 할 일이 없습니다.

뭔가 서비스 개발에 집중할 수 있고 좋음 

 

 

 

 

8. 에러가 뜨면 해결합니다.  

 

보통 에러메세지가 뜨면 구글 검색하시면 대부분 쉽게 해결가능합니다.

하지만 AWS 이런거보다 검색결과가 적어 문의 채팅 보내는게 더 빠를 수 있습니다. 

대표적인 에러 몇개만 봅시다.

 

 

0. app.yaml 파일이 없어요 에러

위를 참고해서 빨리 만드십시오.

 

1. 결제가 안되었습니다 에러 

에러 메세지에 Billing Must be Enabled~ 카드 등록이 안되었어요~ 결제 계정 등록이 안되었어요~ 그러면 빨리 구글 클라우드 홈으로 가서 카드를 등록하십시오

 

2. MongoDB 연결 에러

DB 접속 어쩌구가 안된다고 하면 MongoDB Atlas로 가서 왼쪽 Network Access 에서 IP whitelist를 모든 아이피 접속가능하도록 등록하십시오.

 

3. deploy중 계속 멈춰있는 에러 (Updating Service [default]...)

대부분 2번 문제입니다. MongoDB Atlas에서 Network Access - 모든 IP가 접속가능하도록 바꿔주십시오.

혹은 진짜 에러메세지는 좌측 App Engine - 대시보드 - 하단에서 구경가능합니다. 

 



MongoDB 어쩌구라면 95% 확률로 2번과 동일한 문제입니다. 

 

 

 

 

 

 

9. 사이트 어떻게 접속하나요?

 

배포 완료하면 터미널에 여러분 사이트 주소 뜹니다.

까먹으면 여러분 구글 클라우드 플랫폼 - 좌측 App Engine - 대시보드에 가면 주소 나옵니다. 

 

 

 

 

 

10. 업데이트는 어떻게하나요?

 

위의 gcloud init, gcloud app deploy 하던걸 똑같이 반복하시면 됩니다.  

 

 

 

 

 

11. 테스트용이지만 과금이 두렵습니다. 어떻게 완전 삭제합니까?

 

어짜피 자동과금 안되니까 걍 냅두세요.

일시정지하려면 좌측 App Engine - 설정 - 어플리케이션 사용중지 누르시면 됩니다.

(데이터 보관 비용은 쪼끔 청구될 수도 있을 듯 합니다)

아예 삭제하려면 파란 상단메뉴에서 원하는 프로젝트 선택 - 좌측 메뉴 IAM 및 관리자 - 설정 - 삭제 누르시면 됩니다. 

 

 



 

 

구글 클라우드 만으로도 충분히 웹서비스 구현이 가능합니다.

AWS에 비해선 사용자가 적어 참고문헌(구글검색결과..) 등은 떨어질 수 있으나

초심자에게 매우 쉬운 인터페이스와 사용법을 제공하고 있습니다. 

그리고 AWS에 비해 모든게 자동화되어있어서 초보자에게 특히 좋습니다.  

실은 AWS에도 Elastic Beanstalk 쓰시면 이거랑 비슷하게 쉽게 배포가 가능한데 구글이 더 쉬움 

국내서비스 중에 네이버 클라우드도 초심자 친화적이니 한번 고려해보십시오.

 
 1. Mongoose 써야하나요?

 

MongoDB에 데이터입출력을 하고 싶은 경우 nodejs 환경에선 2개의 라이브러리를 사용가능합니다. 

- MongoDB native driver (지금까지 썼던거)

- Mongoose 

둘 중 하나 택1 하면 됩니다. 

 

두 개의 차이점은 JavaScript & jQuery의 차이와 비슷합니다. 

MongoDB native driver로도 모든걸 구현 가능하지만

Mongoose를 쓰면 약간 더 짧고 편하게 쓸 수 있습니다. (함수가 약간 달라짐)

 

 

Mongoose를 쓰면 DB에 데이터를 저장하기 전에 schema라는걸 정의하셔야합니다.

title 필드엔 문자만 넣으세요

content 필드엔 문자만 넣으세요

age 필드엔 숫자만 넣으세요

이런 식으로 필드에 들어갈 내용을 정의부터 합니다.

어떤 식으로 코드를 짜는지 맛을 보자면 

 

 

var blog = new Schema({
    title : String,
    content : String,
    Age : Number
})

var Blog = mongoose.model('Blog', blog) 
▲ Mongoose에서 Schema 만드는 방법입니다. 그냥 대충 이렇게 먼저 코드를 짜는구나~ 라는 느낌만 가져가면 됩니다. 

그럼 이제 유저가 title, content, age를 DB에 저장할 때

미리 정의한 schema와 맞는지 미리 검사할 수 있습니다.

 

 

 

var article = new Blog({
    title:'강남 우동 맛집',
    content: '돈받고 작성한 블로그 글입니다',
    age : 30
})

article.save(); 
▲ Mongoose에서 DB에 게시물 하나 저장하는 법입니다. 

뭔가 코드가 짧아지고 데이터가 문자인지 숫자인지 validation 작업이 쉬워집니다.

 

 

근데 개발 초기엔  document 1개에 어떤 필드들이 들어가야할지 미리 정의하기 어려운 경우가 있습니다.

그럴 땐 Mongoose 쓰는게 귀찮을 수 있긴 하지만 결국 항상 DB에 들어갈 내용을 엄격하게 통제하는게 좋긴 합니다.

 

 

 

MongoDB native driver에선 저런 validation 어떻게 하냐면 그냥 if문 짜면 됩니다.

"유저가 보낸 age 데이터가 숫자 맞는지 확인하고 DB 저장해라~" 라는 if문이요.

근데 귀찮으면 MongoDB Compass 라는 프로그램을 설치하시면

Mongoose처럼 validation을 넣을 수 있습니다. 

MongoDB Compass는 Atlas 그거랑 똑같은 기능을 제공하는 DB조작 프로그램인데

Validation메뉴가 있어서 저렇게 Mongoose 식으로 추가할 수 있습니다.

 

 

Validation 쉬워지고 함수 짧아지고 그런 장점이 있으니

필요할 것 같으면 Mongoose 설치해서 써보면 됩니다.

쓰려면 DB 접속 문법부터 DB 입출력 문법도 Mongoose 식으로 바꾸셔야합니다.

 

 

 

 

 

 

2. 보안 강화 

 

보안은 어려운게 아니라 그냥 악성유저가 되어서 여러분 사이트 테스트해보시면 됩니다.

 

- 이상한 페이지나 URL로 요청을 하는 경우

- 버튼을 두번 누르거나 해서 중복된 요청을 하는 경우

- 회원가입시 아이디란에 한글 넣는 경우

- 필수 입력란인데 빈칸을 보내는 경우

- DB 접속시 회원 비밀번호가 그대로 1234 이렇게 노출되는 경우

 

그리고 헛점들을 막는 코드를 프론트엔드, 백엔드에서 작성하시면 되겠습니다.

물론 프론트엔드에 있는 자바스크립트는 누구나 위조할 수 있으니 서버에서 if문으로 거르는게 완벽한 방어책입니다. 

 

 

 

그리고 자주 알려진 서버 공격 방법에 대한 대응책을 하나 마련해놓는 것도 좋습니다.

 

- 아이디 등 input 입력란에 <script></script> 혹은 db에서 정보를 꺼내는 문법을 작성할 경우

- 다른 유저의 비밀번호를 100만번 시도해서 때려맞추려고 하는 경우

- DB 접속 공용 비밀번호를 qwer1234로 때려맞추는 경우

 

이런 공격들이 유명한데 

넘나 유명해서 express-rate-limit 라이브러리 등 쉽게 해결할 수 있는 라이브러리가 많습니다.

검색 후 필요한 것들을 적용해보시길 바랍니다. 

 

 

 

 

 

 

3. 관리자기능?

 

무슨 서비스든 관리자 기능이 필요합니다. 

관리자 기능도 만드셔야 실제 서비스 완성이라 관리자 기능도 추가해주면 되는데

예를 들어 어떤 관리자 유저는 모든 글 삭제가 가능해야합니다.

어떻게 코드를 짜야할까요?

 

 

당연히 DB에 회원정보 저장할 때 

role : '관리자'

role : '일반유저'

이런 필드도 집어넣어두고

"만약에 role이 '관리자' 라도 글삭제 가능하게 해주세요"

이런 식으로 삭제기능을 업그레이드 해주면 되겠군요.  

 

 

 

 

 

 

 

 

4. 쇼핑몰 어떻게 만드는데요 

 

큰 프로젝트같은거 만들고 싶을 때는

크게 보면 어려워보입니다. 작은거 부터 하나하나 구현해보십시오.

그러면 매우 쉬워집니다. 

 

(1) 상품등록페이지

팔려면 관리자가 상품 게시물 발행부터 해야합니다.

 

(2) 상품진열페이지

이게 있어야 상품을 어디 보여주고 그러지 않을까요. 

 

(3) 주문기능 넣기

그냥 이것도 주문자, 날짜, 상품명, 수량 이런게 들어있는 게시물 발행입니다

무통장입금이면 그냥 주문완료하면 계좌번호만 보여주면 되겠군요 

 

(4) 주문관리페이지

관리자는 모든 주문 게시물을 볼 수 있어야하고

유저는 나의 주문게시물을 볼 수 있어야합니다.

 

(5) 카드결제

카드결제는 PG사와 계약해서 PG사 결제모듈을 쓰는게 일반적입니다. (다날 같은 회사)

어렵다면 아임포트 이런 서비스 쓰면 복붙식으로 개발이 가능합니다. 

 

(6) 기타 필요한 페이지와 기능

님들 DB와 서버에 대해 모르는거 없으니 그냥 알아서 하나씩 만들면 됩니다.

 


5. 하지만 실제 쇼핑몰 서비스는 

▲ 관리자 페이지만 40개 + 유저가 보는 페이지 10개 만드셔야합니다. 

정말 필요한 최소한의 페이지만 뽑아도 페이지 20개는 만들어야할걸요 

혼자 다 하려면 매우 오래걸릴듯

 

 

마케팅 어떻게 할지

쿠팡에 상품등록 어떻게 할지

배송 주문 생산 재고관리는 어떻게 할지

제품촬영 운영 고객전화문의는 어떻게 할지

많은 고민이 필요합니다. 

 

 

개발자 되는게 목표라면 쇼핑몰 만들어보는 것도 좋은 연습이겠으나

빠르게 물건 파는게 목표라면 임대형 쇼핑몰을 이용하는게 가장 빠른 길입니다.

네이버 스마트스토어, cafe24, nhn commerce 이런 곳에서 쇼핑몰 다 완성된거 빌려줍니다.

기능은 완성되어있으니 html css js로 프론트엔드만 슥삭 바꿔주면 됩니다. 

요즘은 비용도 무료임 

 

매출 수백억 찍는 스타일난다, 임블리 같은 곳들도

쇼핑몰 기능개발 직접하지 않았고 cafe24에서 임대해서씁니다. 

 

재화말고 서비스 이런것도 판매가 가능하나

특이한 기능의 쇼핑몰이 필요하다면 직접 만드는 것도 좋겠군요. 

 

 

 

6. 앞으로 더 공부해봐야할 사항들

 

1. 보안강화 기술들

2. ejs 말고 웹앱을 만들 수 있는 프론트엔드 기술 (Vue, React, Angular)

3. 사용자가 업로드한 이미지, 파일 다루는 방법 (이미지 리사이즈, 축소, 검열 등)

4. OAuth 소셜로그인

5. 서버 컴퓨터 메모리 터짐을 방지하기 위해 세션데이터를 서버메모리가 아니라 MongoDB에 저장하는 법 

 

등이 있습니다.

 

 

 

[자주 묻는 질문 코너]

 

Q. 심화 내용도 배우고 싶습니다 

A. 일부 분들이 다 듣고나서 더 심화 내용 없냐고 찾으시는데 

지금까지 배운 1. get, post요청 처리 2. DB에 데이터 입출력 방법 알면 이론상 모든 서비스 알아서 만들 수 있습니다.

nodejs 책 보면 뭔가 더 깊은 내용 다루는 것 같지만

복잡한 것 vs 깊은 것을 잘 구분하시길 바랍니다.

"1. get, post요청 처리 2. DB에 데이터 입출력하기로 웹사이트 복잡하게 만들기"를 깊은 내용으로 오해들 많이 하십니다. 

실은 심화 내용은 유저가 많아지면 어떻게 해야할지 + 코드 관리 편하게 하려면 어떻게 해야할지 그런 내용이 전부입니다. 

 

유저가 많아지면 구글클라우드에서 자동으로 알아서 서버 용량 늘려줍니다. 

개발자 입장에선 GET요청 수를 줄이거나, 이미지 크기를 줄이거나 해서 서버 비용을 줄이는 방법 같은 것도 생각해볼 수 있겠군요.

그리고 관리편하게 하기 위한 해결책은 마이크로서비스 + 컨테이너화하기가 요즘 유행인데

네이버 카카오급은 되어야하는 것들이고 강의 주제를 많이 벗어나겠군요 

 

 

웹서비스 만드는데 필요한 내용은 다 가르쳐드렸으니 여러분 만들고 싶었던걸 혼자 만들어보는게 가장 좋은 학습방법입니다.

유튜브는 사람들 조회수가 높은 게시물 + 영상을 보여주는 게시판일 뿐이고 

인스타그램은 내가 고른 친구들 게시물만 보여주는 게시판일 뿐이고 

당근마켓은 내 근처 게시물만 보여주는 게시판일 뿐입니다 

 

물론 "내 근처 게시물만 보여주려면 어떻게 코드를 짜야하지"

같은 새로운 내용이 필요하면 구글 검색정도면 충분합니다.

그러면 아마 유저의 위도와 경도를 DB에 게시물과 함께 저장하라는 소리를 할듯요 

내가 혼자 구현을 못할 것 같은 기능은 게시판 ㄱㄱ


